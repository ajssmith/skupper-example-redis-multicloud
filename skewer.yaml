title: Redis Multicloud High Availability using Skupper
subtitle: Secure Redis servers across multiple distributed Kubernetes clusters
overview: |
  This example deploys a simple highly available Redis architecture with
  Sentinel across multiple Kubernetes clusters using Skupper.

  In addition to the Redis server and Redis Sentinel, the example
  contains one service:

  * A wiki-getter service that exposes an `/api/search?query=` endpoint. 
    The server returns the result from the Redis cache if present otherwise
    it will retrieve the query via the wiki api and cache the content via
    the Redis primary server.

  With Skupper, you can place the Redis primary server in one cluster and 
  the replica servers in alternative clusters without requiring that
  the servers be exposed to the public internet.
prerequisites:
sites:
  west:
    title: West
    platform: kubernetes
    namespace: west
    env:
      KUBECONFIG: ~/.kube/config-west
  east:
    title: East
    platform: kubernetes
    namespace: east
    env:
      KUBECONFIG: ~/.kube/config-east
  north:
    title: North
    platform: kubernetes
    namespace: north
    env:
      KUBECONFIG: ~/.kube/config-north
  podman-west:
    title: Podman West
    platform: podman
    env:
      SKUPPER_PLATFORM: podman
steps:
  - standard: general/install_the_skupper_command_line_tool
  - standard: kubernetes/set_up_your_kubernetes_cluster
  - standard: podman/set_up_your_podman_environment
  - title: Create your sites
    preamble: |
      A Skupper _site_ is a location where components of your
      application are running.  Sites are linked together to form a
      Skupper network for your application.

      In Kubernetes, use `skupper init` to create a site.  This
      deploys the Skupper router and controller.  Then use `skupper
      status` to see the outcome.

      In Podman, use `skupper init` with the option `--ingress none`
      and use `skupper status` to see the result.

      **Note:** If you are using Minikube, you need to [start minikube
      tunnel][minikube-tunnel] before you run `skupper init`.

      [minikube-tunnel]: https://skupper.io/start/minikube.html#running-minikube-tunnel
    commands:
      west:
        - run: skupper init --site-name west
          output: |
            Waiting for LoadBalancer IP or hostname...
            Waiting for status...
            Skupper is now installed in namespace 'west'.  Use 'skupper status' to get more information.
      east:
        - run: skupper init --site-name east
          output: |
            Waiting for LoadBalancer IP or hostname...
            Waiting for status...
            Skupper is now installed in namespace 'east'.  Use 'skupper status' to get more information.
      north:
        - run: skupper init --site-name north
          output: |
            Waiting for LoadBalancer IP or hostname...
            Waiting for status...
            Skupper is now installed in namespace 'north'.  Use 'skupper status' to get more information.
      podman-west:
        - run: skupper init --site-name podman-west --ingress none
          output: |
            It is recommended to enable lingering for yourname, otherwise Skupper may not start on boot.
            Skupper is now installed for user 'yourname'.  Use 'skupper status' to get more information.
    postamble: |
      As you move through the steps below, you can use `skupper status` at
      any time to check your progress.
  - title: Link your sites
    preamble: |
      A Skupper _link_ is a channel for communication between two sites.
      Links serve as a transport for application connections and
      requests.

      Creating a link requires use of two `skupper` commands in
      conjunction, `skupper token create` and `skupper link create`.

      The `skupper token create` command generates a secret token that
      signifies permission to create a link.  The token also carries the
      link details.  Then, in a remote site, The `skupper link
      create` command uses the token to create a link to the site
      that generated it.

      **Note:** The link token is truly a *secret*.  Anyone who has the
      token can link to your site.  Make sure that only those you trust
      have access to it.

      First, use `skupper token create` in east to generate the
      token.  Then, use `skupper link create` in east, north and podman-west to link the
      sites.
    commands:
      west:
        - run: skupper token create ~/west.token --uses 3
          output: Token written to ~/west.token
      east:
        - run: skupper token create ~/east.token --uses 2
          output: Token written to ~/east.token        
        - run: skupper link create ~/west.token
          output: |
            Site configured to link to https://10.105.193.154:8081/ed9c37f6-d78a-11ec-a8c7-04421a4c5042 (name=link1)
            Check the status of the link using 'skupper link status'.
        - run: skupper link status --wait 60
          apply: test
      north:
        - run: skupper token create ~/north.token --uses 1
        - run: skupper link create ~/west.token
        - run: skupper link create ~/east.token
          output: |
            Site configured to link to https://10.105.193.154:8081/ed9c37f6-d78a-11ec-a8c7-04421a4c5042 (name=link1)
            Check the status of the link using 'skupper link status'.
        - run: skupper link status --wait 60
          apply: test
      podman-west:
        - run: skupper link create ~/west.token
        - run: skupper link create ~/east.token
        - run: skupper link create ~/north.token
    postamble: |
      If your terminal sessions are on different machines, you may need
      to use `scp` or a similar tool to transfer the token securely.  By
      default, tokens expire after a single use or 15 minutes after
      creation.
  - title: Deploy Redis Server and Sentinel
    preamble: |
      We have deployment yamls, detail what is in it, mention init con
    commands: 
      west:
        - run: kubectl apply -f redis-west.yaml
          output: |
            deployment.apps/redis-server created
            configmap/redis created
            deployment.apps/redis-sentinel created
      east:
        - run: kubectl apply -f redis-east.yaml
          output: |
            deployment.apps/redis-server created
            configmap/redis created
            deployment.apps/redis-sentinel created
      north:
        - run: kubectl apply -f redis-north.yaml
          output: |
            deployment.apps/redis-server created
            configmap/redis created
            deployment.apps/redis-sentinel created        
    postamble: |
      Note well that container is waiting on init dependencies
  - title: Expose Redis Server and Sentinel to Application Network
    preamble: |
      We will skupper expose the server and sentinel deployments in each namespace
    commands: 
      west:
        - run: skupper expose deployment redis-server --address redis-server-west
          output: |
            deployment redis-server exposed as redis-server-west
        - run: skupper expose deployment redis-sentinel --address redis-sentinel-west
          output: |
            deployment redis-sentinel exposed as redis-sentinel-west
      east: 
        - run: skupper expose deployment redis-server --address redis-server-east
          output: |
            deployment redis-server exposed as redis-server-east
        - run: skupper expose deployment redis-sentinel --address redis-sentinel-east
          output: |
            deployment redis-sentinel exposed as redis-sentinel-east      
      north:
        - run: skupper expose deployment redis-server --address redis-server-north
          output: |
            deployment redis-server exposed as redis-server-north
        - run: skupper expose deployment redis-sentinel --address redis-sentinel-north
          output: |
            deployment redis-sentinel exposed as redis-sentinel-north
  - title: Observe the set of Redis server and Sentinel services in each Site
    commands:
      west: 
        - run: kubectl get services
          output: |
            NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                        AGE
            redis-sentinel-east    ClusterIP   172.21.112.88    <none>        26379/TCP                      3m37s
            redis-sentinel-north   ClusterIP   172.21.67.12     <none>        26379/TCP                      3m35s
            redis-sentinel-west    ClusterIP   172.21.6.3       <none>        26379/TCP                      9m4s
            redis-server-east      ClusterIP   172.21.241.21    <none>        6379/TCP                       3m45s
            redis-server-north     ClusterIP   172.21.194.72    <none>        6379/TCP                       3m42s
            redis-server-west      ClusterIP   172.21.236.8     <none>        6379/TCP                       9m8s
      east: 
        - run: kubectl get services
          output: |
            NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                        AGE
            redis-sentinel-east    ClusterIP   172.21.243.22    <none>        26379/TCP                      5m10s
            redis-sentinel-north   ClusterIP   172.21.233.113   <none>        26379/TCP                      5m8s
            redis-sentinel-west    ClusterIP   172.21.179.114   <none>        26379/TCP                      10m
            redis-server-east      ClusterIP   172.21.17.63     <none>        6379/TCP                       5m18s
            redis-server-north     ClusterIP   172.21.224.55    <none>        6379/TCP                       5m15s
            redis-server-west      ClusterIP   172.21.3.180     <none>        6379/TCP                       10m
      north: 
        - run: kubectl get services
          output: |
            NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                        AGE
            redis-sentinel-east    ClusterIP   172.21.211.51    <none>        26379/TCP                      5m54s
            redis-sentinel-north   ClusterIP   172.21.66.49     <none>        26379/TCP                      5m52s
            redis-sentinel-west    ClusterIP   172.21.83.179    <none>        26379/TCP                      11m
            redis-server-east      ClusterIP   172.21.54.164    <none>        6379/TCP                       6m2s
            redis-server-north     ClusterIP   172.21.138.118   <none>        6379/TCP                       5m59s
            redis-server-west      ClusterIP   172.21.224.110   <none>        6379/TCP                       11m
  - title: Create Redis services on podman site
    preamble: |
      The podman site does not take part in exchange, service have to be created
    commands: 
      podman-west:
        - run: skupper service create redis-server-north 6379 --host-port 6379
        - run: skupper service create redis-server-west 6379 --host-port 6380
        - run: skupper service create redis-server-east 6379 --host-port 6381
        - run: skupper service create redis-sentinel-north 26379 --host-port 26379
        - run: skupper service create redis-sentinel-west 26379 --host-port 26380
        - run: skupper service create redis-sentinel-east 26379 --host-port 26381
        - run: skupper service status
          output: |
            Services exposed through Skupper:
            ├─ redis-sentinel-east:26379 (tcp)
            │  ╰─ Host ports:
            │     ╰─ ip: * - ports: 26381 -> 26379
            ├─ redis-sentinel-north:26379 (tcp)
            │  ╰─ Host ports:
            │     ╰─ ip: * - ports: 26379 -> 26379
            ├─ redis-sentinel-west:26379 (tcp)
            │  ╰─ Host ports:
            │     ╰─ ip: * - ports: 26380 -> 26379
            ├─ redis-server-east:6379 (tcp)
            │  ╰─ Host ports:
            │     ╰─ ip: * - ports: 6381 -> 6379
            ├─ redis-server-north:6379 (tcp)
            │  ╰─ Host ports:
            │     ╰─ ip: * - ports: 6379 -> 6379
            ╰─ redis-server-west:6379 (tcp)
               ╰─ Host ports:
                     ╰─ ip: * - ports: 6380 -> 6379
  - title: Use Redis command line interface to verify redis-server-north is master
    preamble: |
      Some preamble here
    commands: 
      podman-west:
        - run: redis-cli -p 6379
        - run: 127.0.0.1:6379> ROLE
          output: |
            1) "master"
            2) (integer) 1531796
            3) 1) 1) "redis-server-west"
                  2) "6379"
                  3) "1531796"
               2) 1) "redis-server-east"
                  2) "6379"
                  3) "1531796"
        - run: 127.0.0.1:6379> exit
  - title: Use Redis command line interface to verify redis-server-west is slave
    preamble: |
      Some preamble here
    commands: 
      podman-west:
        - run: redis-cli -p 6380
        - run: 127.0.0.1:6380> ROLE
          output: |
            1) "slave"
            2) "redis-server-north"
            3) (integer) 6379
            4) "connected"
            5) (integer) 1766858
        - run: 127.0.0.1:6380> exit        
  - title: Use Redis command line interface to verify redis-server-east is slave
    preamble: |
      Some preamble here
    commands: 
      podman-west:
        - run: redis-cli -p 6381
        - run: 127.0.0.1:6381> ROLE
          output: |
            1) "slave"
            2) "redis-server-north"
            3) (integer) 6379
            4) "connected"
            5) (integer) 1869714
        - run: 127.0.0.1:6381> exit
  - title: Use Redis command line interface to verify redis-sentinel-north primary status
    preamble: |
      Some preamble here
    commands: 
      podman-west:
        - run: redis-cli -p 26379
        - run: 127.0.0.1:26379> sentinel master redis-skupper
          output: |
           1) "name"
           2) "redis-skupper"
           3) "ip"
           4) "redis-server-north"
           5) "port"
           6) "6379"
           7) "runid"
           8) "b6886088db5911a94403a5d54306e3afc7a135f7"
           9) "flags"
           10) "master"
           ...
        - run: 127.0.0.1:26379> exit
  - title: Use Redis command line to measure latency of servers from podman site
    preamble: |
      Some preamble here (continuos or sample period) in milliseconds min, max, average, samples
      Note, this example used three public cloud locations (DC, London, Dallas). 
    commands: 
      podman-west:
        - run: redis-cli --latency -p 6379 --raw
          output: |
            62 88 68.85 13
        - run: redis-cli --latency -p 6380 --raw
          output: |
            28 38 32.88 24
        - run: redis-cli --latency -p 6381 --raw
          output: |
            110 280 141.43 7
  - title: Deploy the wiki-getter service
    preamble: |
      We will choose the north namespace to create a wiki-getter deployment
      and service. The client in the service will determine the 
      Sentinel service to access the current Redis primary server
      for query and cache updates.
    commands:
      north:
        - run: kubectl apply -f wiki-getter.yaml
          output: |
            deployment.apps/wiki-getter created
            service/wiki-getter created
  - title: Get Wiki content
    preamble: |
      Use `curl` to send a request to querty the Wikipedia API via the 
      wiki-getter service. Note the *X-Response-Time* header for the initial
      query. The application will check the redis cache and if not found
      will fetch from the external Wikipedia API. If the content has been 
      stored, the applications will provide the response directly.
    commands:
      north:
        - run:  kubectl exec -it deployment/wiki-getter -- curl -f -I --head http://wiki-getter:8080/api/search?query=Boston
          output: |
            HTTP/1.1 200 OK
            X-Powered-By: Express
            Content-Type: application/json; charset=utf-8
            Content-Length: 133241
            ETag: W/"20879-1kpFc2Ex5RW7UtS5dMCi1bM6NCA"
            X-Response-Time: 2792.965ms
            Date: Tue, 26 Mar 2024 20:09:13 GMT
            Connection: keep-alive
            Keep-Alive: timeout=5
        - run:  kubectl exec -it deployment/wiki-getter -- curl -f -I --head http://wiki-getter:8080/api/search?query=Boston
          output: |
            HTTP/1.1 200 OK
            X-Powered-By: Express
            Content-Type: application/json; charset=utf-8
            Content-Length: 133239
            ETag: W/"20877-3I5fv/NQC7Ldrjjbw7IHhqHGmMA"
            X-Response-Time: 9.760ms
            Date: Tue, 26 Mar 2024 20:10:29 GMT
            Connection: keep-alive
            Keep-Alive: timeout=5
  - title: Cleaning up
    preamble: |
      To remove Skupper and other resource from this exercise, use the
      following commands.
    commands:
      west:
        - run: kubectl delete -f redis-west.yaml
        - run: skupper delete
      east:
        - run: kubectl delete -f redis-east.yaml
        - run: skupper delete
      north: 
        - run: kubectl delete -f wiki-getter.yaml
        - run: kubectl delete -f redis-north.yaml
        - run: skupper delete
      podman-west:
        - run: skupper delete
summary: |
  This example locates the redis server and sentinel services in different
  namespaces, on different clusters.  Ordinarily, this means that they
  have no way to communicate unless they are exposed to the public
  internet.

  Introducing Skupper into each namespace allows us to create a virtual
  application network that can connect redis services in different clusters.
  Any service exposed on the application network is represented as a
  local service in all of the linked namespaces.

  The redis primary server is located in `north`, but the redis replica 
  services in `west` and `east` can "see" it as if it were local.
  Redis replica operations take place by service name and Skupper
  forwards the requests to the namespace where the corresponding server
  is running and routes the response back appropriately.
